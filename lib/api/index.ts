// API layer - returns mocked promises
// Future: replace with real n8n API calls

import type {
  Recommendation,
  ReviewItem,
  Question,
  Session,
  CheckQuestion,
  CheckResult,
} from '@/lib/mock/data'
import {
  todayRecommendations,
  reviewQueue,
  sampleQuestions,
  sampleSession,
  sampleCheckQuestions,
} from '@/lib/mock/data'

// Today's recommendations
export async function getToday(): Promise<Recommendation[]> {
  // Simulate API delay
  await new Promise((resolve) => setTimeout(resolve, 300))
  return todayRecommendations
}

// Session management
export async function createSession(): Promise<Session> {
  await new Promise((resolve) => setTimeout(resolve, 300))
  return {
    ...sampleSession,
    id: `s${Date.now()}`,
    startedAt: new Date().toISOString(),
  }
}

export async function getSessionQuestions(sessionId: string): Promise<Question[]> {
  await new Promise((resolve) => setTimeout(resolve, 300))
  return sampleQuestions
}

export async function submitSessionAnswers(
  sessionId: string,
  answers: Record<string, string>
): Promise<{ success: boolean }> {
  await new Promise((resolve) => setTimeout(resolve, 500))
  return { success: true }
}

// Review management
export async function getReviews(): Promise<ReviewItem[]> {
  await new Promise((resolve) => setTimeout(resolve, 300))
  return reviewQueue
}

export async function submitReviewResult(
  reviewId: string,
  result: { passed: boolean; feedback?: string }
): Promise<{ success: boolean }> {
  await new Promise((resolve) => setTimeout(resolve, 500))
  return { success: true }
}

// 문제별 힌트 데이터
const PROBLEM_HINTS: Record<string, string[]> = {
  // 구현/입출력 기초
  '1000': [
    '입력을 공백 기준으로 두 수로 나누고 합을 출력하면 끝!',
    'split() 함수를 사용해서 공백으로 입력을 분리해보세요.',
    '두 정수를 더하는 간단한 연산입니다.',
  ],
  '1001': [
    '두 정수를 읽고 뺄셈 결과를 출력하세요.',
    '입력을 공백으로 구분해서 받은 후 A - B를 계산하면 됩니다.',
    '음수 결과도 나올 수 있으니 주의하세요.',
  ],
  '1008': [
    '나눗셈은 실수 출력 형식에 유의(언어별 기본 출력 확인).',
    '정수 나눗셈과 실수 나눗셈의 차이를 확인하세요.',
    '소수점 자릿수를 확인해야 할 수도 있어요.',
  ],
  '2557': [
    '입력 없이 문자열 그대로 출력하면 됩니다.',
    'Hello World!를 그대로 출력하는 문제입니다.',
    '가장 기본적인 출력 문제예요.',
  ],
  '10869': [
    '연산 순서대로 출력(+,-,*,/,%) / 나눗셈은 정수 나눗셈 여부 확인.',
    '사칙연산과 나머지 연산을 순서대로 출력하세요.',
    '나눗셈은 정수 나눗셈(//)을 사용해야 할 수도 있어요.',
  ],
  '10998': [
    '두 수 곱만 출력하면 돼요.',
    'A와 B를 곱한 결과를 출력하세요.',
    '간단한 곱셈 연산입니다.',
  ],
  // 반복문
  '2438': [
    'i번째 줄에 *를 i개 출력하는 패턴.',
    '반복문을 사용해서 1부터 N까지, 각 줄에 해당 줄 번호만큼 별을 출력하세요.',
    '이중 반복문을 사용하면 쉽게 해결할 수 있어요.',
  ],
  '2439': [
    '공백을 먼저 찍고 그 다음 별을 찍으면 오른쪽 정렬됨.',
    '각 줄에서 (N - i)개의 공백을 먼저 출력한 후 i개의 별을 출력하세요.',
    '공백과 별의 개수를 조절해서 오른쪽 정렬을 만들어보세요.',
  ],
  '2739': [
    '1~9까지 반복하면서 N * i 출력.',
    '반복문을 1부터 9까지 돌면서 N * i = (N*i) 형식으로 출력하세요.',
    '구구단 출력 형식을 정확히 맞춰야 해요.',
  ],
  '2741': [
    '1부터 N까지 한 줄씩 출력.',
    '반복문을 1부터 N까지 돌면서 각 숫자를 한 줄에 하나씩 출력하세요.',
    '간단한 반복 출력 문제입니다.',
  ],
  '2742': [
    'N부터 1까지 내려가며 출력.',
    '반복문을 N부터 1까지 역순으로 돌면서 출력하세요.',
    '감소하는 반복문을 사용하면 됩니다.',
  ],
  // 조건문
  '2753': [
    '4의 배수/100의 배수/400의 배수 조건을 순서대로 체크.',
    '윤년 조건: 4의 배수이면서 100의 배수가 아니거나, 400의 배수입니다.',
    '조건문의 순서가 중요해요. 400의 배수 조건을 먼저 체크하는 것이 좋습니다.',
  ],
  '9498': [
    '점수 구간(90/80/70/60)을 조건문으로 분기.',
    '점수에 따라 A(90-100), B(80-89), C(70-79), D(60-69), F(0-59)를 출력하세요.',
    'if-else if-else 구조를 사용하면 깔끔하게 해결할 수 있어요.',
  ],
  // 시간 계산
  '2884': [
    '분에서 45 빼고 음수면 시를 1 줄이며 24시간 처리.',
    '분에서 45를 빼고, 음수가 되면 시에서 1을 빼고 분에 60을 더하세요.',
    '시가 0 미만이 되면 23으로 설정해야 해요.',
  ],
  '2525': [
    '분에 조리시간 더한 뒤 60으로 나눠 시/분 보정.',
    '현재 분에 조리 시간을 더한 후, 60으로 나눈 몫을 시에 더하고 나머지를 분으로 설정하세요.',
    '시가 24 이상이 되면 24로 나눈 나머지를 사용해야 해요.',
  ],
  // 반복 입력(테스트케이스/EOF)
  '10950': [
    '첫 줄 T 읽고 T번 합 출력.',
    '첫 번째 줄에서 테스트 케이스 개수 T를 읽고, T번 반복하면서 A+B를 출력하세요.',
    '반복문으로 여러 테스트 케이스를 처리하는 문제입니다.',
  ],
  '10951': [
    'EOF까지 입력을 계속 받아 처리(파이썬은 try/except).',
    '입력이 끝날 때까지 계속 A+B를 계산해서 출력하세요.',
    '파이썬은 try-except로 EOFError를 처리하고, 다른 언어는 EOF를 체크하세요.',
  ],
  '10952': [
    '0 0이 나올 때까지 반복 후 종료.',
    'A와 B가 모두 0이 될 때까지 반복하면서 A+B를 출력하세요.',
    'while 루프를 사용하고, 0 0을 입력받으면 종료하면 됩니다.',
  ],
  '11021': [
    '출력 포맷 Case #i: 에 합을 붙이기.',
    '각 테스트 케이스마다 "Case #" + 케이스 번호 + ": " + 합 형식으로 출력하세요.',
    '케이스 번호는 1부터 시작합니다.',
  ],
  '11022': [
    '출력 포맷 Case #i: A + B = C 그대로 맞추기.',
    '각 테스트 케이스마다 "Case #" + 번호 + ": " + A + " + " + B + " = " + 합 형식으로 출력하세요.',
    '출력 형식을 정확히 맞춰야 해요.',
  ],
  // 좌표/사분면
  '14681': [
    'x,y 부호 조합으로 1~4사분면 결정.',
    'x>0, y>0 → 1사분면, x<0, y>0 → 2사분면, x<0, y<0 → 3사분면, x>0, y<0 → 4사분면',
    'x와 y의 부호를 확인해서 사분면을 결정하세요.',
  ],
  // 배열/리스트 기초
  '2562': [
    '최댓값과 인덱스(1부터) 같이 저장/업데이트.',
    '배열을 순회하면서 최댓값과 그 인덱스를 함께 추적하세요.',
    '인덱스는 1부터 시작하므로 출력할 때 +1을 해야 할 수도 있어요.',
  ],
  '10818': [
    '한 번 순회하면서 min/max 갱신.',
    '배열을 한 번만 순회하면서 최솟값과 최댓값을 동시에 찾으세요.',
    '초기값을 첫 번째 원소로 설정하고 나머지를 비교하면 됩니다.',
  ],
  '10871': [
    '조건 만족하는 값만 모아서 공백으로 출력.',
    'X보다 작은 수들만 필터링해서 공백으로 구분해 출력하세요.',
    '조건문으로 필터링하고, 출력 형식을 맞춰야 해요.',
  ],
  '3052': [
    '42로 나눈 나머지를 set에 넣고 개수 출력.',
    '각 수를 42로 나눈 나머지를 set 자료구조에 넣으면 중복이 자동으로 제거됩니다.',
    'set의 크기가 서로 다른 나머지의 개수입니다.',
  ],
  // 문자열
  '2675': [
    '문자열 각 문자를 R번 반복해서 새 문자열 만들기.',
    '각 문자를 R번씩 반복해서 새로운 문자열을 만든 후 출력하세요.',
    '이중 반복문을 사용하면 됩니다.',
  ],
  '2908': [
    '문자열로 뒤집어 정수로 비교하면 쉬움.',
    '두 수를 문자열로 변환해서 뒤집은 후, 다시 정수로 변환해 비교하세요.',
    '문자열 슬라이싱이나 reverse()를 사용하면 됩니다.',
  ],
  '2920': [
    '입력 리스트가 1~8인지 8~1인지 비교.',
    '입력이 [1,2,3,4,5,6,7,8]이면 ascending, [8,7,6,5,4,3,2,1]이면 descending, 아니면 mixed입니다.',
    '정렬된 배열과 비교하면 쉽게 판단할 수 있어요.',
  ],
  '1152': [
    '양끝 공백 주의해서 split 결과 길이.',
    '문자열 양끝의 공백을 제거한 후 split()으로 단어를 나누고 개수를 세세요.',
    'trim()이나 strip()을 사용하면 양끝 공백을 제거할 수 있어요.',
  ],
  '1157': [
    '대소문자 통일 후 빈도 세기, 최댓값 중복이면 ?.',
    '모든 문자를 대문자(또는 소문자)로 통일한 후 빈도를 세고, 최댓값이 여러 개면 ?를 출력하세요.',
    '딕셔너리나 배열을 사용해서 각 알파벳의 빈도를 세면 됩니다.',
  ],
  '11720': [
    '숫자를 문자열로 받고 각 자리 합을 더하면 됨.',
    '숫자를 문자열로 받아서 각 자리 숫자를 정수로 변환해 더하세요.',
    '문자열을 순회하면서 각 문자를 정수로 변환해 합산하면 됩니다.',
  ],
  '1316': [
    '이전 문자와 달라질 때 "이미 나온 문자"인지 체크.',
    '문자열을 순회하면서, 문자가 바뀔 때 이전에 나온 문자인지 확인하세요.',
    'set이나 배열을 사용해서 이미 나온 문자를 추적하면 됩니다.',
  ],
  '2941': [
    '특정 패턴들을 한 글자로 치환/스캔하며 카운트.',
    '크로아티아 알파벳 패턴(c=, c-, dz=, d-, lj, nj, s=, z=)을 찾아서 한 글자로 치환한 후 길이를 세세요.',
    '문자열을 순회하면서 패턴을 찾아 치환하면 됩니다.',
  ],
  '5622': [
    '알파벳을 그룹별로 매핑해서 시간 합산.',
    '각 알파벳을 다이얼 번호로 매핑하고, 각 번호에 해당하는 시간(번호+1초)을 더하세요.',
    '알파벳을 그룹별로 나누어 다이얼 번호를 결정하면 됩니다.',
  ],
  '11654': [
    '문자 한 개 입력 → ord(문자) 출력.',
    '문자 하나를 입력받아서 아스키 코드 값을 출력하세요.',
    'ord() 함수나 타입 캐스팅을 사용하면 됩니다.',
  ],
  '15829': [
    '각 문자값과 거듭제곱을 누적(모듈러 연산 꼭 적용).',
    '각 문자에 (a=1, b=2, ...) 값을 곱하고 31의 거듭제곱을 곱한 후 모두 더하세요. 마지막에 1234567891로 나머지 연산을 해야 해요.',
    '거듭제곱을 누적하면서 모듈러 연산을 적용해야 오버플로우를 방지할 수 있어요.',
  ],
  // 수학/그리디/DP
  '1110': [
    '규칙대로 다음 수를 만들며 처음 수로 돌아올 때까지 카운트.',
    '주어진 수의 일의 자리와 십의 자리를 더한 후, 일의 자리를 십의 자리로, 합의 일의 자리를 일의 자리로 해서 새로운 수를 만드세요. 원래 수로 돌아올 때까지 반복하세요.',
    '반복문을 사용해서 사이클을 찾으면 됩니다.',
  ],
  '1546': [
    '최댓값 M으로 모든 점수를 점수/M*100으로 바꿔 평균.',
    '점수들을 새로운 점수(원점수/최댓값*100)로 변환한 후 평균을 구하세요.',
    '모든 점수를 변환한 후 합을 개수로 나누면 됩니다.',
  ],
  '1712': [
    '고정비/가변비/가격 관계식에서 분기점 공식 유도.',
    '손익분기점: 고정비용 / (판매가격 - 가변비용) + 1 (손익분기점을 넘는 최소 판매량)',
    '판매가격이 가변비용보다 작거나 같으면 손익분기점이 없습니다.',
  ],
  '2292': [
    '구간이 6씩 증가하는 층 수 패턴(1, 7, 19, 37…).',
    '중앙 1을 기준으로 각 층의 마지막 번호는 1, 7, 19, 37, ... 패턴입니다. (1 + 6*1, 1+6*1+6*2, ...)',
    'N이 어느 층에 속하는지 찾으면 됩니다.',
  ],
  '2775': [
    'DP로 층/호수 누적합 테이블 만들기.',
    '0층의 i호에는 i명이 살고, k층 n호에는 k층 (n-1)호 + (k-1)층 n호 사람이 살아요.',
    '2차원 배열을 사용해서 동적 계획법으로 해결하면 됩니다.',
  ],
  '2839': [
    '5kg부터 최대한 쓰고 남는 걸 3kg로 맞추기(안 되면 5 줄이기).',
    '5kg 봉지를 최대한 많이 사용하고, 나머지를 3kg로 채우세요. 안 되면 5kg 봉지를 하나 줄이고 다시 시도하세요.',
    '그리디 알고리즘으로 해결할 수 있어요.',
  ],
  '2869': [
    '하루 순증가 A-B로 정상 도달 일수 계산(올림 주의).',
    '하루에 (A-B)만큼 올라가고, 마지막 날에는 A만큼 올라가면 정상에 도달합니다. (V-A) / (A-B)를 올림한 값 + 1이 답입니다.',
    '올림 처리를 정확히 해야 해요.',
  ],
  '4344': [
    '평균 계산 후 평균 초과 인원 비율을 소수점 3자리로 출력.',
    '각 테스트 케이스의 평균을 구한 후, 평균을 넘는 학생 수를 세어 비율을 계산하세요. 소수점 셋째 자리까지 출력해야 해요.',
    '비율을 백분율로 변환하고 포맷팅해야 합니다.',
  ],
  '6064': [
    'x를 고정하고 k를 늘리며 조건 만족 찾기(LCM 범위 제한).',
    'x를 고정하고 k를 M씩 증가시키면서 y 조건을 만족하는지 확인하세요. M*N의 최소공배수까지만 확인하면 됩니다.',
    '중국인의 나머지 정리와 유사한 문제입니다.',
  ],
  '9020': [
    '소수 판별/에라토스테네스로 소수 만들고 가운데부터 탐색.',
    '에라토스테네스의 체로 소수를 구한 후, n/2부터 시작해서 n - i와 i가 모두 소수인지 확인하세요.',
    '가운데부터 탐색하면 차이가 가장 작은 쌍을 찾을 수 있어요.',
  ],
  '1193': [
    '대각선(1,2,3…) 누적합으로 위치 찾고 짝/홀에 따라 분자/분모 결정.',
    '대각선 번호를 찾고, 그 대각선에서의 위치를 계산하세요. 대각선 번호가 홀수면 위에서 아래로, 짝수면 아래에서 위로 진행합니다.',
    '분수 배열의 패턴을 찾아서 계산하면 됩니다.',
  ],
  '1330': [
    'A와 B 비교해서 >, <, == 출력.',
    '두 수를 비교해서 A > B면 ">", A < B면 "<", A == B면 "=="를 출력하세요.',
    '간단한 조건문 문제입니다.',
  ],
  '25304': [
    '(가격×개수) 합이 총액과 같은지 비교.',
    '각 물건의 가격과 개수를 곱한 값들의 합이 영수증 총액과 같은지 확인하세요.',
    '합을 계산한 후 비교하면 됩니다.',
  ],
  '25314': [
    'N/4 만큼 long 반복 후 int 붙이기.',
    'N을 4로 나눈 몫만큼 "long "을 출력한 후 "int"를 출력하세요.',
    '반복문을 사용해서 "long "을 출력하면 됩니다.',
  ],
  '1065': [
    '각 자리 차이가 일정한지 확인(1000 미만은 직접 체크 가능).',
    '각 자리 숫자의 차이가 일정한 수를 한수라고 합니다. 100 미만의 수는 모두 한수이고, 100 이상은 각 자리 차이를 확인하세요.',
    '각 자리 숫자를 추출해서 등차수열인지 확인하면 됩니다.',
  ],
}

// Hint system
export async function getHints(problemId: string): Promise<string[]> {
  await new Promise((resolve) => setTimeout(resolve, 300))
  
  // 문제 ID로 힌트 찾기 (URL에서 문제 번호 추출 또는 직접 숫자)
  let problemNumber = problemId
  
  // URL 형식인 경우 문제 번호 추출 (예: "https://www.acmicpc.net/problem/1000" 또는 "/problem/1000")
  const urlMatch = problemId.match(/\/(\d+)(?:\/|$)/)
  if (urlMatch) {
    problemNumber = urlMatch[1]
  } else {
    // 숫자만 있는 경우 그대로 사용
    problemNumber = problemId.trim()
  }
  
  // 해당 문제의 힌트가 있으면 반환, 없으면 기본 힌트 반환
  const hints = PROBLEM_HINTS[problemNumber]
  
  if (hints && hints.length > 0) {
    return hints
  }
  
  // 기본 힌트 (문제별 힌트가 없는 경우)
  return [
    '문제를 다시 읽어보고 입력과 출력 형식을 확인해보세요.',
    '단계별로 접근해보세요. 먼저 입력을 받고, 처리한 후 출력하는 순서로 생각해보세요.',
    '예제를 직접 손으로 풀어보면서 패턴을 찾아보세요.',
  ]
}

// Understanding check
export async function getCheckQuestions(sessionId: string): Promise<CheckQuestion[]> {
  await new Promise((resolve) => setTimeout(resolve, 300))
  // Return 2-4 random questions
  const shuffled = [...sampleCheckQuestions].sort(() => Math.random() - 0.5)
  return shuffled.slice(0, Math.floor(Math.random() * 3) + 2) // 2-4 questions
}

export async function submitCheckAnswers(
  sessionId: string,
  answers: Record<string, string>
): Promise<CheckResult> {
  await new Promise((resolve) => setTimeout(resolve, 1200))
  
  // Random result for demo
  const results: CheckResult[] = [
    {
      level: 'complete',
      feedback: '접근 방식과 시간 복잡도 분석이 명확하고, 예외 상황까지 잘 고려했어요.',
    },
    {
      level: 'partial',
      feedback: '접근 방식은 잘 설명했지만, 예외 상황에 대한 설명이 부족해요.',
    },
    {
      level: 'surface',
      feedback: '기본적인 풀이 흐름은 이해하고 있지만, 알고리즘의 핵심 원리를 더 깊이 이해할 필요가 있어요.',
    },
  ]
  
  return results[Math.floor(Math.random() * results.length)]
}
